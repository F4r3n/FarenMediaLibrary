#include "ShaderCompiler.h"
#include "glslang/Public/ShaderLang.h"
#include "glslang/SPIRV/SpvTools.h"
#include "glslang/SPIRV/GlslangToSpv.h"
#include "Core/FilePath.h"
#include "Core/Debug.h"
using namespace fm;
using namespace gui;

bool ShaderCompiler::Compile(const fm::FilePath& inPath)
{
	fm::FilePath path(inPath);

	//_path.ToSub("SPIR-V");
	File frag(Folder(path), "frag.frag");
	File vert(Folder(path), "vert.vert");

	EShLanguage lang = EShLanguage::EShLangFragment;
	std::unique_ptr<glslang::TShader> shader = std::make_unique<glslang::TShader>(lang);

	const char* sources[1] = { frag.GetContent().data() };
	shader->setStrings(sources, 1);
	glslang::EShTargetClientVersion targetApiVersion = glslang::EShTargetVulkan_1_3;
	shader->setEnvClient(glslang::EShClientVulkan, targetApiVersion);

	glslang::EShTargetLanguageVersion spirvVersion = glslang::EShTargetSpv_1_3;
	shader->setEnvTarget(glslang::EshTargetSpv, spirvVersion);

	shader->setEntryPoint("main"); // We can specify a different entry point

	// The resource is an entire discussion in and by itself, here just use default.
	//TBuiltInResource* resources = GetDefaultResources();
	// int defaultVersion = 110, // use 100 for ES environment, overridden by #version in shader
	const int defaultVersion = 450;
	const bool forwardCompatible = false;
	const EShMessages messageFlags = (EShMessages)(EShMsgSpvRules | EShMsgVulkanRules);
	EProfile defaultProfile = ENoProfile; // NOTE: Only for desktop, before profiles showed up!

	// NOTE: Here a custom file I/O library is used, your implementation may be different.
	//fileio::Directory* shaderdir = ...
	//	GlslShaderIncluder includer(shaderdir);
	glslang::TShader::ForbidIncluder includer;

	std::string preprocessedStr;
	if (!shader->preprocess(
		nullptr, defaultVersion, defaultProfile, false, forwardCompatible, messageFlags, &preprocessedStr, includer))
	{
		DEBUG_ERROR(shader->getInfoLog())
		//log_error("Failed to preprocess shader: {}", shader.getInfoLog());
		// FAIL
	}
	const char* preprocessedSources[1] = { preprocessedStr.c_str() };
	shader->setStrings(preprocessedSources, 1);

	if (!shader->parse(nullptr, defaultVersion, defaultProfile, false,
		forwardCompatible, messageFlags, includer))
	{
		DEBUG_ERROR(shader->getInfoLog())
		return false;
		//vtek_log_error("Failed to parse shader: {}", shader.getInfoLog());
		// FAIL
	}

	glslang::TProgram program;
	program.addShader(shader.get());
	if (!program.link(messageFlags))
	{
		DEBUG_ERROR(program.getInfoLog())
		//vtek_log_error("Failed to link shader: {}", program.getInfoLog());
		// FAIL
	}

	program.buildReflection();
	//program.dumpReflection()

	// Convert the intermediate generated by glslang to Spir-V
	glslang::TIntermediate* intermediateRef = (program.getIntermediate(lang));
	std::vector<uint32_t> spirv;
	glslang::SpvOptions options{};
	options.validate = true;
	// TODO: We can also provide a logger to glslang.
	// glslang::spv::SpvBuildLogger logger;
	// glslang::GlslangToSpv(intermediateRef, spirv, &logger, &options);
	glslang::GlslangToSpv(*intermediateRef, spirv, &options);

	return true;
}
